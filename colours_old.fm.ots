// ᕦ(ツ)ᕤ
// colours.fm.ts
// feature modular struct extension

import { Feature, feature, on, after, before, fm, console_separator} from "./fm.ts";

export function struct<T extends { new (...args: any[]): {} }>(constructor: T) {
    const className = constructor.name;
    const prototype = Object.getPrototypeOf(constructor.prototype);
    const superClassConstructor = prototype ? prototype.constructor : null;
    const superClassName = superClassConstructor ? superClassConstructor.name : 'None';
    console.log(`struct ${className} extends ${superClassName}`);
}

export function make(target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const method = descriptor.value;
    const className = target.constructor.name;
    console.log(`construct ${className}()`);
}

//------------------------------------------------------------------------------

interface Colour { r: number, g: number, b: number };
declare const colour: (r: number, g: number, b: number) => Colour;
declare const add: (a: Colour, b: Colour) => Colour; 

@feature class _Colour extends Feature {
    @on colour(r: number=0, g: number=0, b: number=0)  {
        return { r: r, g: g, b: b } as Colour;
    }
    @on add(a: Colour, b: Colour) : Colour {
        return { r: a.r+b.r, g: a.g+b.r, b: a.b+b.r} as Colour;
    }
}

//------------------------------------------------------------------------------

interface AlphaColour extends Colour { a: number };
declare const alpha: (colour: Colour, a: number) => AlphaColour;

@feature class _Alpha extends _Colour {
    @on alpha(col: Colour, a: number=0) {
        return { ...col, a: a } as AlphaColour;
    }
    @on add(a: AlphaColour, b: AlphaColour) : AlphaColour {
        return alpha(add(a, b), a.a+b.a);
    }
}